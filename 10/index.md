# Chapter 14. 인덱싱

1. 기본 개념
2. 순서 인덱스
3. B<sup>+</sup> - 트리 인덱스 파일
4. B<sup>+</sup> - 트리 확장
5. 해시 인덱스
6. 다중 키 접근
7. 인덱스 생성
8. 쓰기 최적화 인덱스 구조
9. 비트맵 인덱스
10. 공간/시간 데이터의 인덱스

## 14.1. 기본 개념

인덱스를 사용하면 빠르게 찾을 수 있다.
ex) 주어진 ID를 가진 student 레코드를 검색하기 위해, dbms는 인덱스를 사용해 대응되는 레코드가 어느 블록에 있는지 찾은 후, student 레코드를 얻기 위해 해당 블록을 가져온다.

인덱스의 두 가지 기본적인 종류

- 순서(Ordered) 인덱스: 값에 대해 정렬된 순서
- 해시(Hash) 인덱스: 버킷의 범위 안에서 값이 일정하게 분배. 값이 할당되는 버킷은 해시 함수에 의해 결정.

여러 순서 인덱스를 살펴볼 것인데, 이들을 평가하는 기준은 다음과 같다

- 접근 유형(Access type): 효율적으로 지원되는 접근 유형.
- 접근 시간(Access time): 특정 데이터 항목 or 항목 집합을 찾는 데 걸리는 시간.
- 삽입 시간(Insertion time): 새 데이터 삽입에 걸리는 시간. (데이터 항목을 삽입하기 위한 정확한 위치를 찾는데 걸리는 시간)과 (인덱스 구조를 갱신하는 데 걸리는 시간)을 포함한다.
- 삭제 시간(Deletion time): 데이터 항목 삭제에 걸리는 시간. (삭제될 항목을 찾는 데 걸리는 시간)과 (인덱스 구조를 갱신하는 데 걸리는 시간)을 포함한다.
- 공간 부담(Space overhead): 인덱스 구조가 사용하는 부가적인 공간. 부가적인 공간의 양이 적정선 내라면, 성능 향상을 위해 공간을 늘리는 것은 일반적으로 가치있는 일이다.


하나의 파일에 한 개 이상의 인덱스가 자주 필요할 수 있다.
- 검색 키(search key): 한 파일에서, 레코드를 찾는 데 사용되는 속성이나 속성들의 집합
검색 키를 이해했다면, 한 파일에 대해 여러 개의 인덱스가 있다면 검색 키도 여러 개 있다고 생각할 수 있다.

## 14.2. 순서 인덱스
파일 안에 있는 레코드에 대한 임의 접근(random access)를 빨리 하기 위해 인덱스 구조를 이용할 수 있다.
순서 인덱스는 검색 키의 값을 정렬된 순서로 저장하고, 검색 키와 검색 키를 포함하는 레코드를 연계시킨다.

클러스터링 인덱스 = 군집 인덱스 = clustering index = clustered index = primary index = 기본 인덱스    
비클러스터링 인덱스 = 비군집 인덱스 = nonclustering index = nonclustered index = secondary index = 보조 인덱스   

레코드를 포함하는 파일이 연속적인 순서로 되어있다면 -> 클러스터링 인덱스는 그 파일을 연속적인 순서로 정의한 속성을 검색키로 사용하는 인덱스.

이름만 보면, 기본 인덱스(primary index)는 주 키(primary key)에 대한 인덱스를 의미하는 용어로 나타날 수 있다.
하지만 사실 임의의 어떤 검색 키에 대해서도 기본 인덱스를 구축할 수 있다.
클러스터링 인덱스의 검색 키는 주 키인 경우가 많지만 반드시 그럴 필요는 없다.

파일의 연속적인 순서와 다른 순서로 구성되는 검색 키의 인덱스 = 비 클러스터링 인덱스.   

14.2.1절 ~ 14.2.3절: 모든 파일은 어떤 검색 키에 의한 연속적인 순서로 정렬되어 있다고 가정한다.
검색 키에 대해 기본 인덱스를 가지는 위와 같은 파일을 인덱스 순차 파일(index-sequential file)이라 부르며, dbms에서 사용된 가장 오래된 인덱스 구조 중 하나다.
전체 파일의 연속적인 처리와 각 레코드에 대해 임의적 접근이 필요한 경우 이러한 인덱스를 설계한다.
다음은 인덱스 순차 파일 사진이다.
<img width="379" alt="image" src="https://user-images.githubusercontent.com/102134003/181868706-0b11b48d-567e-4923-b5ee-dd2285315176.png">
<br>
14.2.4절에서 보조 인덱스에 대해 다룬다


### 14.2.1 밀집과 희소 인덱스
인덱스 레코드(index record) = 인덱스 엔트리(index entry)는 검색 키 값과 포인터로 구성되어 있다.
포인터 = 검색 키 값으로 가지는 한 개 이상의 레코드에 대한 포인터.
레코드에 대한 포인터 = 디스크 블록 식별자 + 블록 안에서 레코드를 구별하기 위한 디스크 블록 안의 오프셋으로 구성.

<br>
순서 인덱스의 두 가지 유형


- 밀집 인덱스

<img width="503" alt="image" src="https://user-images.githubusercontent.com/102134003/181876276-a9de1346-2bb1-4c9a-b45d-69a8036587c8.png">
인덱스 엔트리는 파일에 있는 모든 검색 키 값에 대해 나타난다.
밀집 클러스터링 인덱스에서, 인덱스 레코드는 검색키 값과 그 키 값의 첫 레코드에 대한 포인터를 포함한다.

밀집 비클러스터링 인덱스에서, 인덱스 레코드는 검색키 값을 가진 모든 레코드에 대한 포인터 목록을 저장한다.

- 희소 인덱스

<img width="510" alt="image" src="https://user-images.githubusercontent.com/102134003/181876283-a64d5f15-671c-4526-b4bb-e843f77db3e1.png">
인덱스 엔트리는 검색 키 값에 대해 단지 몇 개만 나타난다.
릴레이션이 검색 키로 정렬되 저장된 경우(클러스터링 인덱스인 경우) 에만 사용할 수 있다.
밀집 인덱스처럼, 검색 키 값과 그에 대한 첫 데이터 레코드 포인터를 포함한다.



데이터 탐색에 있어, 밀집 인덱스가 희소 인덱스보다 빠르다.
반면, 희소 인덱스는 더 적은 공간을 요구해서, 삽입-삭제에 대한 유지 부담이 더 적다.
접근 시간(access time) vs 공간 부담(space overhead) 사이의 선택이다.
즉, 어느 것을 선택하느냐는 응용 프로그램에 따라 다를 수 있다.



그렇더라도 일반적으로 가장 좋은 절충안은 존재하는데, 바로 블록 당 하나의 인덱스 엔트리를 가지는 희소 인덱스이다.
그 이유는, db 요구를 처리하는데 드는 비용 중 가장 지배적인 것은 메인 메모리로 블록을 가져오는 데 걸리는 시간이기 때문이다.
블록을 가져오고 나서, 블록 내에서 걸리는 시간은 대수롭지 않다.
이 희소 인덱스를 사용하면, 찾고자 하는 레코드를 포함하는 블록을 얻을 수 있다.
따라서 이 레코드에 대한 오버플로 블록이 없다면, 인덱스 크기를 작게 유지하며 블록 접근을 최소화해야 한다.



앞의 기술을 완전히 일반화하려면, 하나의 검색 키 값에 대한 레코드가 여러 개의 블록을 차지하고 있는 경우를 생각해야 한다.
